## TP 02 : Services, processus signaux

## 1 Secure Shell : SSH

### 1.1 Exercice : Connexion ssh root

Pour se connecter en root sur notre VM, on veut authoriser les connexion en root.
Dans le `man sshd_config` on trouve la liste des options que l'on peut configurer, celle qui nous intéresse ici est `PermitRootLogin`, qu'on va définir à `true`.
Cette option nous permettra de nous connecter en tant qu'administrateur, avec un mot de passe.

### 1.2 Exercice : Authentication par clef / Génération de clefs

Pour créer une clef d'authentification, on peut lire le `man ssh-keygen`.
`ssh-keygen` permet de générer des clefs, on y trouve l'option `-t` pour spécifier le type de clef que l'on veut générer.
Ici on fera:

```
ssh-keygen -t rsa
Generating public/private rsa key pair.
Enter file in which to save the key (/home/mimi/.ssh/id_rsa):
Enter passphrase for "/home/mimi/.ssh/id_rsa" (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in /home/mimi/.ssh/id_rsa
Your public key has been saved in /home/mimi/.ssh/id_rsa.pub
```

On voit bien que la clef a été générée et qu'elle est sauvegardée dans un repertoire de mon utilisateur. Cette clef n'est faite que pour mon utilisateur courant `mimi`.

### 1.3 Exercice Authentication par clef / Connection serveur

On dépose note clef publique sur la VM dans `/root/.ssh/authorized_keys` grace à la commande `ssh-copy-id -i ~/.ssh/id_rsa.pub root@192.168.174.15`.
Dans la VM on `chmod 600 /root/.ssh/authorized_keys` pour ne donner les droits de lecture et d'écriture qu'à root.
On en profite pour changer la config d'ssh dans `/etc/ssh/ssh_config` pour autoriser les connexion avec clef (`PubkeyAuthentication yes`).

### 1.4 Exercice : Authentification par clef : depuis la machine hote

Maintenant on peut se connecter :
`ssh -i .ssh/id_rsa.pub root@192.168.174.15`
On rentre notre passphrase et on peut se connecter maintenant sans mdp.

### 1.5 Exercice : Sécurisez

Les attaques de type brute-force ssh consistent à tester des combinaisons user/passwd en grand nombre pour trouver la bonne.
Pour éviter ce genre d'attaque, on peut désactiver la connexion par mot de passe de note serveur.
Pour cela on se rend dans notre configuration sshd de notre VM (`/etc/ssh/sshd_config`) et on desactive la connexion par mot de passe :
`PasswordAuthentication no`
De plus pour protéger root dans une VM avec d'autres utilisateurs, on peut empecher les connexions à root directement avec l'option:
`PermitRootLogin no`

Maintenant on ne peux plus se connecter, ni en tant que root et ni avec un mot de passe, il ne reste que la connexion à un utilisateur avec une clef ssh.

## 2 Processus

### 2.1 Exercice : Etude des processus UNIX

#### 1

Pour afficher la liste des processus on utilise la commande `ps aux`
La colonne `TIME` indique le temps cumulé d'utilisation du processeur
Pour savoir quel processus l'a utilisé le plus, on peut trier avec l'option `sort`: `ps aux --sort time`, dans mon cas on trouve `kworker` cumulant 0:04 temps d'utilisation.
De la même manière on peut sort par la colonne `START`, on trouve `sbin/init`.

Pour trouver l'heure de démarrage, on peut se fier à l'heure à laquel le premier processus à été lancé. Sinon ont peut aller vérifier l'heure d'écriture du premier processeur dans le dossier `proc` : `ls -ld /proc/1`
En regardant le PID du dernier processus, on peut estimer le nombre de processus créés depuis le démarrage, ici on est aux alentours de 1100.

#### 2

`ps xao` permet d'afficher les colonnes que l'on veut, on doit lui passer des options.
`ps xao pid,ppid,comm` par exemple permet d'afficher le `pid`, le `ppid` et le nom du processus.
`ps axjf` permet elle d'afficher tous les processus en triant delon leur PPID.
Quand on regarde les processus parents de `ps axjf`, on voit dans l'ordre:
- bash
- sshd-session: root@pts/0
- sshd-session: root [priv]
- sshd: /usr/sbin/sshd ...

#### 3

on met à jour le système `apt update`
On cherche le package contenant `pstree` avec `apt search pstree` et on trouve:
```
psmisc/stable 23.7-2 amd64
  utilities that use the proc file system
```
On l'installe avec `apt install psmisc`.

`pstree` permet de voir un arbre de processus, on peut trier le résultat avec plusieurs options.

#### 4

Pour trier on peut utiliser `R R` puis naviguer sur la colonne qui nous intéresse, on trouve `systemd` qui utilise 14372bits de mémoire.
Systemd est une collection de service de gestion du système linux. Il s'occupe d'énormément de chose, dont par exemple le démarrage du système, ou une partie de la connexion internet, etc.
Pour mettre `top` en couleur, on utilise la commande `z`.
Pour highlight la colonne: `x`.
Pour changer de colonne: `< ou >`.

`htop` a l'avantage d'être colorée de base et plus simple à prendre en main je pense.
Par contre elle n'est pas installée de base.

## 3 Exercice 2: Arrêt d'un processus 

Après écriture et lancement des deux scripts, on peut les arréter en utilisant:
- `fg` puis `CTRL + C`
- `ps aux | grep date` pour trouver le PID qui fait tourner le programme et `kill -9 1438` (ici notre PID) pour le tuer.

Fonctionnement des scripts:
- `#!/bin/sh` définit quel shell fait tourner le script.
- `while true` crée une boucle infinie.
- `do sleep 1` le met en pause de 1s.
- `echo -n date` affiche `date` dans la console.
- `date +%T` affiche la date `now` au format HH:mm:ss et `date --date '5 hours ago' +%T` renvoie la date indiquée par la chaine de caractère, toujours au format HH:mm:ss.
- `done` met fin à la boucle infinie.

## Exercice 3: Les tubes

`cat` concatène un fichier ou un pipe et le renvoie à l'output.
`tee`lit l'input (pipe ou autre) et l'écrit dans un fichier. 

- `ls | cat` liste tous les fichiers d'un répertoire, puis les concatène pour les afficher dans la console.
- `ls -l | cat > list` liste tous les fichiers d'un répertoire sous forme de liste complète, les concatène et cette fois l'écrit dans un nouveau fichier `list`
- `ls -l | tee list` liste tous les fichiers d'un répertoire sous forme de liste complète, puis l'écrit dans le fichier `list` et l'affiche dans la console.
- `ls -l | tee list | wc -l` liste tous les fichiers d'un répertoire sous forme de liste complète, puis l'écrit dans le fichier `list`, puis wl -c affiche dans la console le nombre de ligne du nouveau fichier crée.

## 5 Journal système rsyslog

- Le service `rsyslog` est démarré sur ma VM, le PID du démon est 1267.
- `rsyslog` écrit les logs dans plusieurs fichiers. 
  - `/var/log/syslog` pour tous les fichiers sauf !:
  - `/var/log/auth.log` pour les log d'authentification.
  - `/var/log/cron.log` pour les log du cron.
  - `/var/log/kern.log` pour les log du noyaux (kernel).
  - `/var/log/mail.log` pour les log du service smtp (je suppose).
  - `/var/log/user.log` pour les log d'utilisateur.
En regardant dansle répertoire, on voit que auth est quasi vide (on y voit que ma connection root de cette session). user.log et mail.log sont inexistants et Cron quasi vide également. Par contre les logs du kernel et défaut sont remplis.

- Le service cron sert à lancer des scripts à intervals réguliers.

- `tail` sert à afficher les dernières lignes d'un fichier. L'option `-f` sert à rendre en temps réel des ajout au fichier regardé, c'est très utile quand on regarde un fichier de log justement. N'ayant pas de fichier `var/log/message` je peux regarder l'impact du démarrage d'un cron dans le fichier `var/log/cron.log` en temps réel.

- `logrotate` est un service d'archivage des logs. Il possède des options modifiable dansle fichier `/etc/logrotate.conf` comme la compression, la fréquence d'archivage, le renommage du fichier de log, etc.

- `dmesg` est une commande qui donne beaucoup d'infos sur le kernel. On peut y trouver les interractions avec les composants materiels, notamment avec la carte resaux sur cette ligne:
`[    0.854053] e1000 0000:00:03.0 eth0: Intel(R) PRO/1000 Network Connection`
Ou le processeur:
`[    0.000007] tsc: Detected 2495.998 MHz processor` même si je ne trouve pas son nom
